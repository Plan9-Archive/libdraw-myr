use std
use sys

use "types"
use "chan"
use "image"
use "pack"

pkg draw =
	const load	: (dpy : display#, buf : byte[:] -> std.result(image#, err))
;;

const load = {dpy, buf
	var chan, rect, compressed
	var img

	if !parsehdr(buf, &chan, &rect, &compressed, &buf)
		-> `std.Err `Efmt
	;;

	img =  genallocimage(dpy, 0, Refnone, chan, DWhite, false, rect, rect)
	if compressed
		if !loadcomp(dpy, img, buf)
			-> `std.Err `Efmt
		;;
	else
		if !loadraw(dpy, img, buf)
			-> `std.Err `Efmt
		;;
	;;
	-> `std.Ok img
}

const loadcomp = {dpy, img, buf
	var n, y, dy, err

	y = img.r.y0
	while y != img.r.y1
		if buf.len < 24
			-> false
		;;
		err = false
		dy = getint(buf[:12], &err)
		n = getint(buf[12:24], &err)
		if err
			-> false
		;;
		buf = buf[24:]
		pack(dpy, "biiiiid", (n : std.size), \
			('Y' : byte), \
			img.id, \
			img.r.x0, \
			y, \
			img.r.x1, \
			y + dy, \
			buf[:n])
		y += dy
	;;
	-> true
}

const loadraw = {dpy, img, buf
	var chunk, btp, btl
	var n, r, dx, dy

	r = img.r
	dx = r.x1 - r.x0
	btp = (chandepth(img.chan) / 8 : int)
	btl = btp * dx
	chunk = dpy.buf.len - 64
	while r.y0 != r.y1
		dy = r.y1 - r.y0
		/* FIXME: deal with images where btl > chunk */
		if dy * btl > chunk
			dy = chunk / btl
		;;
		n = dy * btl
		pack(dpy, "biiiiid", (n : std.size), \
			('y' : byte), \
			img.id, \
			r.x0, \
			r.y0, \
			r.x1, \
			r.y0 + dy, \
			buf[:n])
		buf = buf[n:]
		r.y0 += dy
	;;
	-> true
}

const parsehdr = {buf, chanp, rectp, compressedp, bufp
	if buf.len < 5*12
		-> false
	;;
	if std.sleq(buf[:11], "compressed\n") && buf.len >= 5*12 + 11
		compressedp# = true
		bufp# = buf[5*12 + 11:]
		-> parsefmt(buf[11:11+5*12], chanp, rectp)
	else
		compressedp# = false
		bufp# = buf[5*12:]
		-> parsefmt(buf[:5*12], chanp, rectp)
	;;
}

const parsefmt = {buf, chanp, rectp
	var spbuf : byte[:][5]
	var sp, err

	sp = std.bstrtok(spbuf[:], buf)
	if sp.len == 0
		-> false
	;;

	match chanparse(sp[0])
	| `std.Some c:	chanp# = c
	| `std.None:	std.fatal("bad chan\n"); -> false
	;;

	err = false
	rectp.x0 = getint(sp[1], &err)
	rectp.y0 = getint(sp[2], &err)
	rectp.x1 = getint(sp[3], &err)
	rectp.y1 = getint(sp[4], &err)
	-> !err
}

/*
const readall = {fd, buf
	var n

	n = 0
	while n < buf.len
		match std.read(fd, buf[n:])
		| `std.Err e:	-> false
		| `std.Ok 0:	-> n == buf.len
		| `std.Ok l:
			n += l
		;;
	;;
	-> true
}
*/
