use std
use sys

use "types"
use "chan"
use "image"
use "pack"

pkg draw =
	const load	: (dpy : display#, buf : byte[:] -> std.result(image#, err))
;;

const load = {dpy, buf
	var chan, rect, compressed
	var img

	if !parsehdr(buf, &chan, &rect, &compressed, &buf)
		-> `std.Err `Efmt
	;;

	img = allocimage(dpy, rect, DWhite, false)
	if compressed
		if !loadcomp(dpy, img, buf)
			-> `std.Err `Efmt
		;;
	else
		if !loadraw(dpy, img, buf)
			-> `std.Err `Efmt
		;;
	;;
	-> `std.Ok img
}

const loadcomp = {dpy, img, buf
	-> false
}

const loadraw = {dpy, img, buf
	var chunk, btp, btl
	var n, r, dx, dy

	r = img.r
	dx = r.x1 - r.x0
	btp = (chandepth(img.chan) / 8 : int)
	btl = btp * dx
	chunk = dpy.buf.len - 64
	while r.y0 != r.y1
		dy = r.y1 - r.y0
		if dy * btl > chunk
			dy = chunk / btl
		;;
		n = dy * btl
		pack(dpy, "biiiiid", (n : std.size), \
			('y' : byte), \
			img.id, \
			r.x0, \
			r.y0, \
			r.x1, \
			r.y0 + dy, \
			buf[:n])
		buf = buf[n:]
		r.y0 += dy
	;;
	-> true
}

const parsehdr = {buf, chanp, rectp, compressedp, bufp
	if buf.len < 5*12
		-> false
	;;
	if std.sleq(buf[:11], "compressed\n") && buf.len >= 5*12 + 11
		compressedp# = true
		bufp# = buf[5*12 + 11:]
		-> parsefmt(buf[:11+5*12], chanp, rectp)
	else
		compressedp# = false
		bufp# = buf[5*12:]
		-> parsefmt(buf[:5*12], chanp, rectp)
	;;
}

const parsefmt = {buf, chanp, rectp
	var spbuf : byte[:][5]
	var sp, err

	sp = std.bstrtok(spbuf[:], buf)
	if sp.len == 0
		-> false
	;;

	match chanparse(sp[0])
	| `std.Some c:	chanp# = c
	| `std.None:	-> false
	;;

	err = false
	rectp.x0 = getint(sp[1], &err)
	rectp.y0 = getint(sp[2], &err)
	rectp.x1 = getint(sp[3], &err)
	rectp.y1 = getint(sp[4], &err)
	-> !err
}

/*
const readall = {fd, buf
	var n

	n = 0
	while n < buf.len
		match std.read(fd, buf[n:])
		| `std.Err e:	-> false
		| `std.Ok 0:	-> n == buf.len
		| `std.Ok l:
			n += l
			std.put("buf[:{}]: {}\n", n, buf[:n])
		;;
	;;
	std.put("read all. buf: {e}\n", buf)
	-> true
}
*/
